<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit! | Godekfredes</title><meta name=keywords content><meta name=description content="Title: You Won&rsquo;t Believe How Easy It Is to Create a Bulletproof RPC Interface for Your Ajax Apps Using Google Web Toolkit!
Introduction: Ajax is a powerful web development technique that allows developers to build web applications that provide a seamless user experience. However, building a robust RPC (Remote Procedure Call) interface for Ajax applications is not always easy. Developers need to ensure that the RPC interface is secure, efficient, and reliable."><meta name=author content="Matthew Pierson"><link rel=canonical href=https://godekfredes.github.io/posts/how-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://godekfredes.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://godekfredes.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://godekfredes.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://godekfredes.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://godekfredes.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit!"><meta property="og:description" content="Title: You Won&rsquo;t Believe How Easy It Is to Create a Bulletproof RPC Interface for Your Ajax Apps Using Google Web Toolkit!
Introduction: Ajax is a powerful web development technique that allows developers to build web applications that provide a seamless user experience. However, building a robust RPC (Remote Procedure Call) interface for Ajax applications is not always easy. Developers need to ensure that the RPC interface is secure, efficient, and reliable."><meta property="og:type" content="article"><meta property="og:url" content="https://godekfredes.github.io/posts/how-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843/"><meta property="og:image" content="https://godekfredes.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-03T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-03T00:00:00+00:00"><meta property="og:site_name" content="Godekfredes"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://godekfredes.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit!"><meta name=twitter:description content="Title: You Won&rsquo;t Believe How Easy It Is to Create a Bulletproof RPC Interface for Your Ajax Apps Using Google Web Toolkit!
Introduction: Ajax is a powerful web development technique that allows developers to build web applications that provide a seamless user experience. However, building a robust RPC (Remote Procedure Call) interface for Ajax applications is not always easy. Developers need to ensure that the RPC interface is secure, efficient, and reliable."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://godekfredes.github.io/posts/"},{"@type":"ListItem","position":2,"name":"You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit!","item":"https://godekfredes.github.io/posts/how-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit!","name":"You won\u0027t believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit!","description":"Title: You Won\u0026rsquo;t Believe How Easy It Is to Create a Bulletproof RPC Interface for Your Ajax Apps Using Google Web Toolkit!\nIntroduction: Ajax is a powerful web development technique that allows developers to build web applications that provide a seamless user experience. However, building a robust RPC (Remote Procedure Call) interface for Ajax applications is not always easy. Developers need to ensure that the RPC interface is secure, efficient, and reliable.","keywords":[],"articleBody":" Title: You Won’t Believe How Easy It Is to Create a Bulletproof RPC Interface for Your Ajax Apps Using Google Web Toolkit!\nIntroduction: Ajax is a powerful web development technique that allows developers to build web applications that provide a seamless user experience. However, building a robust RPC (Remote Procedure Call) interface for Ajax applications is not always easy. Developers need to ensure that the RPC interface is secure, efficient, and reliable. In this article, we will show you how to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit (GWT).\nWhat is Google Web Toolkit? Google Web Toolkit (GWT) is an open-source web framework that allows developers to build complex web applications using Java. GWT is designed to simplify the development of complex Ajax applications by providing a set of tools and libraries that make it easy to create rich, interactive web applications.\nCreating a Bulletproof RPC Interface Using GWT: GWT provides a powerful RPC framework that allows developers to create a robust and secure interface for their Ajax apps. Here’s how to do it:\nStep 1: Define Your Service Interfaces The first step in creating a bulletproof RPC interface using GWT is to define your service interfaces. A service interface defines the methods that your Ajax application will call on the server. To define your service interfaces, create a new Java interface and annotate it with the “@RemoteServiceRelativePath” annotation.\nStep 2: Create Your Service Implementation Once you have defined your service interfaces, you need to create your service implementation. This implementation will be responsible for handling the requests and responses from your Ajax application. To create your service implementation, create a new Java class and extend the “RemoteServiceServlet” class.\nStep 3: Configure Your Web.xml File The next step is to configure your web.xml file. This file tells your web server how to map URLs to servlets. To configure your web.xml file, add a new servlet mapping for your service implementation.\nStep 4: Use Your Service in Your Ajax Application Finally, you are ready to use your service in your Ajax application. To use your service, first, create a new instance of your service interface using the “GWT.create()” method. Then, you can call the methods on your service interface using the callback mechanism provided by GWT.\nConclusion: As you can see, creating a bulletproof RPC interface for your Ajax apps using GWT is not only easy but also efficient and reliable. By following the steps outlined in this article, you can build robust and secure Ajax applications that provide a seamless user experience. So why wait? Start building your bulletproof RPC interface using GWT today!\nThese are some of the advantages that I believe makes GWT a good choice for building a web application:\nGWT is freely available from Google and there is a large developer community for it. GWT apps are coded entirely in Java and there is no need to understand JavaScript unless you want to add very specialized customization. The Java source is compiled into JavaScript optimized for each possible client browser, so you can take advantage of all browsers equally with a single set of source code. GWT apps are well supported across most browsers. All of the development tools needed are available for free, including Eclipse as an IDE and plenty of plugins to enhance it. Numerous third party toolkits that provide additional widgets, functionality, and support. GWT utilizes a sophisticated and powerful, yet simple-to-use, Remote Proceedure Call (RPC) mechanism to provide AJAX-style communication between the client and server. The last bullet is a key feature of GWT that makes building AJAX functionality quite simple. But if the RPC interface you build is not designed correctly, you could be opening up the server-side of your application to vulnerability. The rest of this article will cover some design principles that should be considered if you want to be sure that the communication between the client and server is secure.\nA fictional web application example First I’ll be providing a brief overview of how to build a GWT RPC interface. It is important to note that this article is not meant to be a guide on how to build a GWT RPC interface. The point of this article is to explain how to design your interface in a secure way once you are already familiar with the implementation details. Please refer to the GWT RPC documentation for details on how to build, use, and deploy an interface if you are not already familiar with it. The infrastructure that GWT RPC provides gives you the ability to have your server offer Java functions that can be called from the client as if making a regular Java function call, with the only caveat being that all function returns are done asynchronously and never synchronously. You can pass entire objects as input parameters and as return parameters — GWT RPC will take care of the marshalling of these complex data types for you. Apache Tomcat is typcially used to host the servlet or servlets that provide the server-side code for the RPC interface. The client code is JaveScript, compiled from the Java source by the GWT compiler, running in the browser. Our web application example will be access to a list of contacts that can be viewed or edited. On the server we will have a database that stores the contacts. The client UI will give the end user the ability to view the current set of contacts, add, edit, or delete contacts from the list, and send an email to anyone on the contact list. To further illustrate security principles in the design of the RPC interface for this app, end users will need to log in and certain users will have access to only certain subsets of the entire list of contacts. The RPC service will be called ContactsService and the service interface would be defined in ContactsService.java like this: The service async interface would then be defined in ContactsServiceAsync.java like this: So in the client code, when you need to call a function in the RPC interface, the client would invoke it like this:\nRemember what is on the client and what is on the server The reason for having an RPC interface is so that you can implement your web application in a way that utilizes code running both in the client browser and on the server. Code running on the server would typically be used to read and write a database or to invoke functionality that cannot be done from a sandboxed web browser, i.e., sending an email or connecting to servers other than the server that served up the client code (most browsers will block this to prevent cross-site scripting attacks). So in general: code running on the client provides the user interface and direct interaction with the user, and code running on the server provides the actual data manipulation that the client code is driving. For this reason, the server is the side you need to guard carefully. Code that executes on the client should not be responsible for security in any way. Client code is served up to the end user and once given to them they have the ability to potentially modify it in any way. There are plenty of browser plugins that allow access to and modification of code served for a web application. And the end user may not even be using a standard browser. HTTP is an open protocol and therefore anyone who has access permission (as administered on the web server) to your web application has the ability to get your application’s code. You may think that using an obfuscator on your web application’s client code would make the client code secure from end-user tampering but most obfuscators are able to be foiled – although at this point you have raised the bar a little bit higher. But note that the server-side of your RPC service is still open to be called even by someone who has access to your web application but may not be able to access in any usable way the client code meant to invoke that interface. The functions on your server are callable by anyone that has access to your web application A very important point to be made here (and the crux of this article) is that all of the function calls hosted on your server can be called by anyone that has access to your web application regardless of whatever you put in your client code. As illustrated in the above section you cannot rely on your client code to guard what can be done through your RPC interface. You need to design your RPC interface in a way that only authorized end users can do what you have authorized them to do.\nUse the session to track the end user The server used to host your RPC interface keeps track of all client sessions with the server. Once a browser instance requests anything from the server, the server will track that particular browser instance and any subsequent request from the same browser instance – even from a different tab or window, they will be tracked as being in the same session. The session will be remembered even if the network connection between client and server is severed for some time period. The session is tracked on the server with the HttpSession object. In your server code, this can be accessed from the HttpServletRequest object which is available in any RPC function implementation. Note that the RPC implementation class extends RemoteServiceServlet which extends HttpServlet. [The HttpServlet class is a powerful class that provides access to everything about the connection between the client and the server. The javadoc for HttpServlet is a valuable reference.] All of the functions available in HttpServlet are therefore available within the implementation of any of your RPC functions. The following code gives an example of how to use the session to track if the user is considered by your server implementation to be logged in or not: For simplicity the code example uses the username to track the currently logged in user. But you probably want to use something like the database ID of the login entry that is likely to be more persistent over time. Note that the session attributes appear to work like a cookie. But setting a session attribute is much different than using a cookie. Cookies are tracked on the client side by the browser. The end user has full access to the store of cookies and can easily tamper with them. Session attributes are stored only on the server and the client has no way of accessing them. If you choose to store any state about the server locally on the client, make sure that it is only in addition to and not instead of storing the same state on the server. The bottom line is that the server alone should hold the authoritative state of the ability to access any element of the server. If the client wants to ask if a particular user is currently logged in, it should ask the server via an RPC call — and that RPC function should verify that the caller has the right to ask the question before returning an answer.\nCheck access rights on every RPC call Remember that a malicious attacker will not respect your idea of which RPC functions to call in which order. They can potentially call any function in any order and pass in any data of the types that the functions accept as parameters. Every single function in your RPC interface must verify that the current session is authorized to get back any information the function may return (e.g. any of the contacts in the list of contacts) or is authorized to carry out any activity the function may do (e.g. send an email, modify the database, etc.). Building on our example, every RPC function must at the very least check to see if the current session is logged in before continuing to carry out the function. And it should additionally verify that the currently logged in user has permissions to carry out the function. For example, when querying the list of contacts, certain users should only see a subset of the list of all contacts. Your database design should contain the information used to track who has access to what. The function getContacts() will do nothing if the current session is not logged in and if a user is properly logged in, it will filter out to only the Contacts that the current user has the rights to view:\nSummary This method is one of the safest I know for building an RPC interface. However, there are other methods and you may find another scheme that works better for your particular situation, especially depending on the level of security you need for your server. I would love to hear from folks if they have different methods that have worked well for them in the comments below.\nUseful Links GWT Home Page — The top level of all information Google provides on GWT GWT Developer’s Guide — The best place to get started with GWT GWT Server Communication — How to create an RPC interface\nHttpServlet\n","wordCount":"2214","inLanguage":"en","datePublished":"2022-12-03T00:00:00Z","dateModified":"2022-12-03T00:00:00Z","author":{"@type":"Person","name":"Matthew Pierson"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://godekfredes.github.io/posts/how-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843/"},"publisher":{"@type":"Organization","name":"Godekfredes","logo":{"@type":"ImageObject","url":"https://godekfredes.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://godekfredes.github.io/ accesskey=h title="Godekfredes (Alt + H)"><img src=https://godekfredes.github.io/apple-touch-icon.png alt aria-label=logo height=35>Godekfredes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://godekfredes.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://godekfredes.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://godekfredes.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://godekfredes.github.io/posts/>Posts</a></div><h1 class=post-title>You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit!</h1><div class=post-meta><span title='2022-12-03 00:00:00 +0000 UTC'>December 3, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2214 words&nbsp;·&nbsp;Matthew Pierson</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#a-fictional-web-application-example>A fictional web application example</a></li><li><a href=#remember-what-is-on-the-client-and-what-is-on-the-server>Remember what is on the client and what is on the server</a></li><li><a href=#use-the-session-to-track-the-end-user>Use the session to track the end user</a></li><li><a href=#check-access-rights-on-every-rpc-call>Check access rights on every RPC call</a></li></ul></li><li><a href=#summary>Summary</a><ul><li><a href=#useful-links>Useful Links</a></li></ul></li></ul></nav></div></details></div><div class=post-content><hr><p>Title: You Won&rsquo;t Believe How Easy It Is to Create a Bulletproof RPC Interface for Your Ajax Apps Using Google Web Toolkit!</p><p>Introduction:
Ajax is a powerful web development technique that allows developers to build web applications that provide a seamless user experience. However, building a robust RPC (Remote Procedure Call) interface for Ajax applications is not always easy. Developers need to ensure that the RPC interface is secure, efficient, and reliable. In this article, we will show you how to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit (GWT).</p><p>What is Google Web Toolkit?
Google Web Toolkit (GWT) is an open-source web framework that allows developers to build complex web applications using Java. GWT is designed to simplify the development of complex Ajax applications by providing a set of tools and libraries that make it easy to create rich, interactive web applications.</p><p>Creating a Bulletproof RPC Interface Using GWT:
GWT provides a powerful RPC framework that allows developers to create a robust and secure interface for their Ajax apps. Here&rsquo;s how to do it:</p><p>Step 1: Define Your Service Interfaces
The first step in creating a bulletproof RPC interface using GWT is to define your service interfaces. A service interface defines the methods that your Ajax application will call on the server. To define your service interfaces, create a new Java interface and annotate it with the &ldquo;@RemoteServiceRelativePath&rdquo; annotation.</p><p>Step 2: Create Your Service Implementation
Once you have defined your service interfaces, you need to create your service implementation. This implementation will be responsible for handling the requests and responses from your Ajax application. To create your service implementation, create a new Java class and extend the &ldquo;RemoteServiceServlet&rdquo; class.</p><p>Step 3: Configure Your Web.xml File
The next step is to configure your web.xml file. This file tells your web server how to map URLs to servlets. To configure your web.xml file, add a new servlet mapping for your service implementation.</p><p>Step 4: Use Your Service in Your Ajax Application
Finally, you are ready to use your service in your Ajax application. To use your service, first, create a new instance of your service interface using the &ldquo;GWT.create()&rdquo; method. Then, you can call the methods on your service interface using the callback mechanism provided by GWT.</p><p>Conclusion:
As you can see, creating a bulletproof RPC interface for your Ajax apps using GWT is not only easy but also efficient and reliable. By following the steps outlined in this article, you can build robust and secure Ajax applications that provide a seamless user experience. So why wait? Start building your bulletproof RPC interface using GWT today!</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/VOf27ez_Hvg style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><p>These are some of the advantages that I believe makes GWT a good choice for building a web application:</p><p>GWT is freely available from Google and there is a large developer community for it.
GWT apps are coded entirely in Java and there is no need to understand JavaScript unless you want to add very specialized customization. The Java source is compiled into JavaScript optimized for each possible client browser, so you can take advantage of all browsers equally with a single set of source code.
GWT apps are well supported across most browsers.
All of the development tools needed are available for free, including Eclipse as an IDE and plenty of plugins to enhance it.
Numerous third party toolkits that provide additional widgets, functionality, and support.
GWT utilizes a sophisticated and powerful, yet simple-to-use, Remote Proceedure Call (RPC) mechanism to provide AJAX-style communication between the client and server. </p><p>The last bullet is a key feature of GWT that makes building AJAX functionality quite simple. But if the RPC interface you build is not designed correctly, you could be opening up the server-side of your application to vulnerability. The rest of this article will cover some design principles that should be considered if you want to be sure that the communication between the client and server is secure.</p><h3 id=a-fictional-web-application-example>A fictional web application example<a hidden class=anchor aria-hidden=true href=#a-fictional-web-application-example>#</a></h3><p>First I’ll be providing a brief overview of how to build a GWT RPC interface.
It is important to note that this article is not meant to be a guide on how to build a GWT RPC interface. The point of this article is to explain how to design your interface in a secure way once you are already familiar with the implementation details. Please refer to the GWT RPC documentation for details on how to build, use, and deploy an interface if you are not already familiar with it.
The infrastructure that GWT RPC provides gives you the ability to have your server offer Java functions that can be called from the client as if making a regular Java function call, with the only caveat being that all function returns are done asynchronously and never synchronously. You can pass entire objects as input parameters and as return parameters — GWT RPC will take care of the marshalling of these complex data types for you.
Apache Tomcat is typcially used to host the servlet or servlets that provide the server-side code for the RPC interface. The client code is JaveScript, compiled from the Java source by the GWT compiler, running in the browser.
Our web application example will be access to a list of contacts that can be viewed or edited. On the server we will have a database that stores the contacts. The client UI will give the end user the ability to view the current set of contacts, add, edit, or delete contacts from the list, and send an email to anyone on the contact list. To further illustrate security principles in the design of the RPC interface for this app, end users will need to log in and certain users will have access to only certain subsets of the entire list of contacts.
The RPC service will be called ContactsService and the service interface would be defined in ContactsService.java like this:
The service async interface would then be defined in ContactsServiceAsync.java like this:
So in the client code, when you need to call a function in the RPC interface, the client would invoke it like this:</p><h3 id=remember-what-is-on-the-client-and-what-is-on-the-server>Remember what is on the client and what is on the server<a hidden class=anchor aria-hidden=true href=#remember-what-is-on-the-client-and-what-is-on-the-server>#</a></h3><p>The reason for having an RPC interface is so that you can implement your web application in a way that utilizes code running both in the client browser and on the server. Code running on the server would typically be used to read and write a database or to invoke functionality that cannot be done from a sandboxed web browser, i.e., sending an email or connecting to servers other than the server that served up the client code (most browsers will block this to prevent cross-site scripting attacks).
So in general: code running on the client provides the user interface and direct interaction with the user, and code running on the server provides the actual data manipulation that the client code is driving. For this reason, the server is the side you need to guard carefully.
Code that executes on the client should not be responsible for security in any way. Client code is served up to the end user and once given to them they have the ability to potentially modify it in any way. There are plenty of browser plugins that allow access to and modification of code served for a web application. And the end user may not even be using a standard browser. HTTP is an open protocol and therefore anyone who has access permission (as administered on the web server) to your web application has the ability to get your application’s code.
You may think that using an obfuscator on your web application’s client code would make the client code secure from end-user tampering but most obfuscators are able to be foiled – although at this point you have raised the bar a little bit higher.
But note that the server-side of your RPC service is still open to be called even by someone who has access to your web application but may not be able to access in any usable way the client code meant to invoke that interface.
The functions on your server are callable by anyone that has access to your web application
A very important point to be made here (and the crux of this article) is that all of the function calls hosted on your server can be called by anyone that has access to your web application regardless of whatever you put in your client code.  As illustrated in the above section you cannot rely on your client code to guard what can be done through your RPC interface.
You need to design your RPC interface in a way that only authorized end users can do what you have authorized them to do.</p><h3 id=use-the-session-to-track-the-end-user>Use the session to track the end user<a hidden class=anchor aria-hidden=true href=#use-the-session-to-track-the-end-user>#</a></h3><p>The server used to host your RPC interface keeps track of all client sessions with the server. Once a browser instance requests anything from the server, the server will track that particular browser instance and any subsequent request from the same browser instance – even from a different tab or window, they will be tracked as being in the same session. The session will be remembered even if the network connection between client and server is severed for some time period.
The session is tracked on the server with the HttpSession object. In your server code, this can be accessed from the HttpServletRequest object which is available in any RPC function implementation. Note that the RPC implementation class extends RemoteServiceServlet which extends HttpServlet. [The HttpServlet class is a powerful class that provides access to everything about the connection between the client and the server. The javadoc for HttpServlet is a valuable reference.] All of the functions available in HttpServlet are therefore available within the implementation of any of your RPC functions.
The following code gives an example of how to use the session to track if the user is considered by your server implementation to be logged in or not:
For simplicity the code example uses the username to track the currently logged in user. But you probably want to use something like the database ID of the login entry that is likely to be more persistent over time.
Note that the session attributes appear to work like a cookie. But setting a session attribute is much different than using a cookie. Cookies are tracked on the client side by the browser. The end user has full access to the store of cookies and can easily tamper with them. Session attributes are stored only on the server and the client has no way of accessing them. If you choose to store any state about the server locally on the client, make sure that it is only in addition to and not instead of storing the same state on the server.
The bottom line is that the server alone should hold the authoritative state of the ability to access any element of the server. If the client wants to ask if a particular user is currently logged in, it should ask the server via an RPC call — and that RPC function should verify that the caller has the right to ask the question before returning an answer.</p><h3 id=check-access-rights-on-every-rpc-call>Check access rights on every RPC call<a hidden class=anchor aria-hidden=true href=#check-access-rights-on-every-rpc-call>#</a></h3><p>Remember that a malicious attacker will not respect your idea of which RPC functions to call in which order. They can potentially call any function in any order and pass in any data of the types that the functions accept as parameters.
Every single function in your RPC interface must verify that the current session is authorized to get back any information the function may return (e.g. any of the contacts in the list of contacts) or is authorized to carry out any activity the function may do (e.g. send an email, modify the database, etc.).
Building on our example, every RPC function must at the very least check to see if the current session is logged in before continuing to carry out the function. And it should additionally verify that the currently logged in user has permissions to carry out the function. For example, when querying the list of contacts, certain users should only see a subset of the list of all contacts. Your database design should contain the information used to track who has access to what.
The function getContacts() will do nothing if the current session is not logged in and if a user is properly logged in, it will filter out to only the Contacts that the current user has the rights to view:</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>This method is one of the safest I know for building an RPC interface. However, there are other methods and you may find another scheme that works better for your particular situation, especially depending on the level of security you need for your server.
I would love to hear from folks if they have different methods that have worked well for them in the comments below.</p><h3 id=useful-links>Useful Links<a hidden class=anchor aria-hidden=true href=#useful-links>#</a></h3><p>GWT Home Page — The top level of all information Google provides on GWT
GWT Developer’s Guide — The best place to get started with GWT
GWT Server Communication — How to create an RPC interface</p><p>HttpServlet</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://godekfredes.github.io/posts/how-to-change-the-instagram-app-icon-on-android-ios137642/><span class=title>« Prev</span><br><span>You Won't Believe How Easy It Is To Change Your Instagram App Icon On Android & iOS - Tons Of Stylish Options To Choose From!</span></a>
<a class=next href=https://godekfredes.github.io/posts/how-to-change-the-icons-names-on-android-homescreen1401601/><span class=title>Next »</span><br><span>You Won't Believe How Easy It Is To Personalize Your Android Homescreen With These Icon Name Change Tips!</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit! on twitter" href="https://twitter.com/intent/tweet/?text=You%20won%27t%20believe%20how%20easy%20it%20is%20to%20create%20a%20bulletproof%20RPC%20interface%20for%20your%20Ajax%20apps%20using%20Google%20Web%20Toolkit%21&url=https%3a%2f%2fgodekfredes.github.io%2fposts%2fhow-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit! on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fgodekfredes.github.io%2fposts%2fhow-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843%2f&title=You%20won%27t%20believe%20how%20easy%20it%20is%20to%20create%20a%20bulletproof%20RPC%20interface%20for%20your%20Ajax%20apps%20using%20Google%20Web%20Toolkit%21&summary=You%20won%27t%20believe%20how%20easy%20it%20is%20to%20create%20a%20bulletproof%20RPC%20interface%20for%20your%20Ajax%20apps%20using%20Google%20Web%20Toolkit%21&source=https%3a%2f%2fgodekfredes.github.io%2fposts%2fhow-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit! on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fgodekfredes.github.io%2fposts%2fhow-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843%2f&title=You%20won%27t%20believe%20how%20easy%20it%20is%20to%20create%20a%20bulletproof%20RPC%20interface%20for%20your%20Ajax%20apps%20using%20Google%20Web%20Toolkit%21"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit! on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fgodekfredes.github.io%2fposts%2fhow-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit! on whatsapp" href="https://api.whatsapp.com/send?text=You%20won%27t%20believe%20how%20easy%20it%20is%20to%20create%20a%20bulletproof%20RPC%20interface%20for%20your%20Ajax%20apps%20using%20Google%20Web%20Toolkit%21%20-%20https%3a%2f%2fgodekfredes.github.io%2fposts%2fhow-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share You won't believe how easy it is to create a bulletproof RPC interface for your Ajax apps using Google Web Toolkit! on telegram" href="https://telegram.me/share/url?text=You%20won%27t%20believe%20how%20easy%20it%20is%20to%20create%20a%20bulletproof%20RPC%20interface%20for%20your%20Ajax%20apps%20using%20Google%20Web%20Toolkit%21&url=https%3a%2f%2fgodekfredes.github.io%2fposts%2fhow-to-build-a-secure-rpc-interface-for-ajax-apps-with-google-web-toolkit-454843%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://godekfredes.github.io/>Godekfredes</a></span></footer><script type=text/javascript src=//normallydemandedalter.com/48/f2/62/48f262e63869c6b4229e3455c07958bc.js></script>
<script type=text/javascript>var _Hasync=_Hasync||[];_Hasync.push(["Histats.start","1,4695461,4,0,0,0,00010000"]),_Hasync.push(["Histats.fasi","1"]),_Hasync.push(["Histats.track_hits",""]),function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//s10.histats.com/js15_as.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><noscript><a href=/ target=_blank><img src=//sstatic1.histats.com/0.gif?4695461&101 alt border=0></a></noscript><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>